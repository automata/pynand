// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 512 rows (indexed 0..511, top to bottom)
 * of 256 pixels each (indexed 0..255, left to right). The top left pixel on
 * the screen is indexed (0,0).
 */
class Screen {
    static boolean color;

    // Array of 16 masks, each with the corresponding pixel set:
    static Array pixels;

    // Array of 16 masks, each with the corresponding pixel, and its neighbors to the left, set:
    static Array leftPixels;

    /** Initializes the Screen. */
    function void init() {
        var int x, bit, leftBits;

        let color = true;

        let pixels = Array.new(16);
        let leftPixels = Array.new(16);
        let x = 0;
        let bit = 1;
        let leftBits = 1;
        while (x < 16) {
            let pixels[x] = bit;
            let leftPixels[x] = leftBits;
            let x = x + 1;
            let bit = bit + bit;
            let leftBits = leftBits + leftBits + 1;
        }
        // let leftPixels[9] = 5 + 16*5;

        return;
    }

    /** Erases the entire screen. */
    function void clearScreen() {
        var Array screen;
        var int count;

        let screen = 16384;
        let count = 8192;

         while (~(count < 0)) {
            let screen[0] = 0;
            let screen = screen + 1;
            let count = count - 1;
         }

        return;
    }

    /** Sets the current color, to be used for all subsequent drawXXX commands.
     *  Black is represented by true, white by false. */
    function void setColor(boolean b) {
        // Note: explicitly `true` so *all* the bits are set.
        if (b) {
            let color = true;
        }
        else {
            let color = false;
        }

        return;
    }

    /** Draws the (x,y) pixel, using the current color. */
    function void drawPixel(int x, int y) {
        var int word, mask;
        var Array ptr;

        if ((x < 0) | (x > 511) | (y < 0) | (y > 255)) {
            return;
        }

        // TODO: unroll * and /
        let word = x/16;
        let mask = pixels[x - (word*16)];
        let ptr = 16384 + (32*y) + word;

        let ptr[0] = (ptr[0] & ~mask) | (color & mask);

        return;
    }

    /** Draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */
    function void drawLine(int x1, int y1, int x2, int y2) {
        var int start, end, word, wordX, mask;
        var Array ptr;

        var int tmp, dx, dy, cx, cy, diff;

        if (y1 = y2) {
            // This case has to be fast, because it's used for drawRectangle, which is
            // the only one anybody expects to be quick. Note: min/max for input validation
            // is currently a large chunk of the time. TODO: factor that out when using
            // drawRectangle.

            // TODO: handle *both* coords outside the range
            // TODO: avoid the function calls
            let start = Math.max(0, Math.min(x1, x2));
            let end = Math.min(511, Math.max(x1, x2));

            // Inlined and un-rolled:
            // let word = start/16;
            let word = 0;
            if (start & 16) { let word = 1; }
            if (start & 32) { let word = word + 2; }
            if (start & 64) { let word = word + 4; }
            if (start & 128) { let word = word + 8; }
            if (start & 256) { let word = word + 16; }

            // wordX = word*16; // i.e. start % 16
            let wordX = start & ~15;

            // ptr = 16384 + (32*y1) + word
            let ptr = y1 + y1;    // 2*y1
            let ptr = ptr + ptr;  // 4*y1
            let ptr = ptr + ptr;  // 8*y1
            let ptr = ptr + ptr;  // 16*y1
            let ptr = ptr + ptr;  // 32*y1
            let ptr = 16384 + ptr + word;

            // First mask off a partial word on the left, if needed:
            if (start > wordX) {
                let mask = ~leftPixels[(start - wordX) - 1];
                if (end < (wordX + 15)) {
                    let mask = mask & leftPixels[end - wordX];
                }
                let ptr[0] = (ptr[0] & ~mask) | (color & mask);

                // let word = word + 1;  // unused
                let wordX = wordX + 16;
                let ptr = ptr + 1;
            }

            // Now a fast loop for any whole words:
            while (~((wordX+16) > end)) {  // i.e. wordX + 16 <= end
                let ptr[0] = color;

                // let word = word + 1;  // unused
                let wordX = wordX + 16;
                let ptr = ptr + 1;
            }

            // Finally, mask off any partial word on the right:
            if (~(wordX > end)) {  // i.e. wordX <= end
                let mask = leftPixels[end - wordX];
                let ptr[0] = (ptr[0] & ~mask) | (color & mask);

                // no need to update the state
            }

            return;
        }

        if (x1 = x2) {
            // Vertical lines are simple, but don't need to be especially fast:
            let start = Math.min(y1, y2);
            let end = Math.max(y1, y2);
            while (~(start > end)) {
                // TODO: inline and do the masking and ptr arithmetic directly here
                do Screen.drawPixel(x1, start);
                let start = start + 1;
            }

            return;
        }


        // General case:

        // Always draw left-to-right:
        if (x2 < x1) {
            let tmp = x2; let x2 = x1; let x1 = tmp;
            let tmp = y2; let y2 = y1; let y1 = tmp;
        }

        // Note: no constraint on the extremes; lines can start/end off screen, and the
        // on-screen portion will be accurate. This does mean wasting some time calculating
        // the locations of off-screen pixels, though, especially if the input is *way*
        // out of range.

        // Bresenham's algorithm, with separate cases for when x or y is the "long axis"
        // see (https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm). This produces
        // a better result than the simpler algorithm described by the authors; the line
        // always arrives at the final pixel, and "steps" are distributed evenly around
        // the middle.
        if (y1 < y2) {
            // Positive slope (down and to the right, in these coordinates):
            let dx = (x2 - x1);
            let dy = (y2 - y1);
            let cx = 0;
            let cy = 0;

            if (~(dx < dy)) {  // i.e. dx >= dy
                // cx always advances; add to cy as needed
                let diff = (dy+dy) - dx;
                while (~(cx > dx)) {  // i.e. cx <= dx
                    do Screen.drawPixel(x1 + cx, y1 + cy);

                    if (diff > 0) {
                        let cy = cy + 1;
                        let diff = diff - (dx+dx);
                    }
                    let diff = diff + (dy+dy);

                    let cx = cx + 1;
                }
            }
            else {
                // cy always advances; add to cx as needed
                let diff = (dx+dx) - dy;
                while (~(cy > dy)) {  // i.e. cy <= dy
                    do Screen.drawPixel(x1 + cx, y1 + cy);

                    if (diff > 0) {
                        let cx = cx + 1;
                        let diff = diff - (dy+dy);
                    }
                    let diff = diff + (dx+dx);

                    let cy = cy + 1;
                }
            }
        }
        else {
            // Negative slope, same thing but draw upside down:
            let dx = (x2 - x1);
            let dy = -(y2 - y1);
            let cx = 0;
            let cy = 0;

            if (~(dx < dy)) {   // "First octant": dx >= dy
                let diff = (dy+dy) - dx;
                while (~(cx > dx)) {  // i.e. cx <= dx
                    do Screen.drawPixel(x1 + cx, y1 - cy);

                    if (diff > 0) {
                        let cy = cy + 1;
                        let diff = diff - (dx+dx);
                    }
                    let diff = diff + (dy+dy);

                    let cx = cx + 1;
                }
            }
            else {
                // cy always advances; add to cx as needed
                let diff = (dx+dx) - dy;
                while (~(cy > dy)) {  // i.e. cy <= dy
                    do Screen.drawPixel(x1 + cx, y1 - cy);

                    if (diff > 0) {
                        let cx = cx + 1;
                        let diff = diff - (dy+dy);
                    }
                    let diff = diff + (dx+dx);

                    let cy = cy + 1;
                }
            }
        }

        return;
    }

    /** Draws a filled rectangle whose top left corner is (x1, y1)
     * and bottom right corner is (x2,y2), using the current color. */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        var Array ptr;
        var int y_start, y_end;
        var int x_start, x_end;

        // TODO: handle *both* coords outside the range
        let y_start = Math.max(0, Math.min(y1, y2));
        let y_end = Math.min(255, Math.max(y1, y2));

        while (~(y_start > y_end)) {  // i.e. y_start <= y_end
            do Screen.drawLine(x1, y_start, x2, y_start);
            let y_start = y_start + 1;
        }

        return;
    }

    /** Draws a filled circle of radius r<=181 around (x,y), using the current color. */
    function void drawCircle(int x, int y, int r) {
        // Note drawing in one direction (down from the top) is slower (twice as many sqrt()s),
        // but looks nicer. Actually, the authors' version draws four lines at a time, which
        // looks super goofy.

        // Subtracting 1/2 from the radius smooths out the compass points, and duplicating
        // the middle row restores the expected radius, or at least reproduces something close
        // to the authors' rendering. Actually, theirs isn't even round!

        var int i, dy, dx;
        var int rSq;

        if (r > 181) {
            return;
        }

        let rSq = (r*r) - r;  // (r - 1/2)^2 = r^2 - r (+ 1/4)

        let i = -r + 1;
        while (~(i > r)) {  // i.e. i <= r
            if (i > 0) { let dy = i - 1; } else { let dy = i; }
            let dx = Math.sqrt(rSq - (dy*dy));
            do Screen.drawRectangle(x - dx, y + dy, x + dx, y + dy);
            let i = i + 1;
        }

        return;
    }
}
